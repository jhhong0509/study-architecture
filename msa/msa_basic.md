# MSA

## MSA란

MSA는 **하나의 어플리케이션을 적당히 작은 서비스로 개발하는 접근**이다.

각각의 어플리케이션은 **API 형태로 외부에 노출**되고, 실질적인 세부사항은 모두 추상화 된다.

<br>

각각의 어플리케이션은 **독립적인 프로세스**로 실행되어야 하고 **경량화된 메커니즘으로 커뮤니케이션**해야 한다.

또한 **각각의 어플리케이션은 개별적으로 배포**할 수 있어야 한다.

<br>

### 장점

- **분산형 개발을 통해 효율적인 개발이 가능하다**

  예를 들어 상품 관리 팀 에서는 상품 관리 기능만, 유저 관리 팀에서는 유저 관리 기능만 만들면 된다.

- **개별 서비스가 다른 서비스에 부정적인 영향을 주지 않을 수 있다**

  하나의 서버에서 문제가 발생해도 연관되지 않는 서버들은 정상적으로 동작할 수 있다.

- **Scale-out이 간편하다**

- **언어의 제약이 사라진다**

  하나의 마이크로 서비스는 다른 마이크로 서버들의 언어에 구애받지 않을 수 있다.

  따라서 어플리케이션마다 원하는 프레임워크를 써볼수도 있고, 신기술을 사용해볼수도 있다.

- **새로운 기능 확장에 유연해 진다**

<br>

### 단점

- **장애 추적이 힘듬**
- **구현이 힘듬**
- **트랜잭션 관리가 힘듬**
- **서비스들의 모니터링에 대한 오버헤드 존재**
- **네트워크 통신에 의한 오버헤드 존재**

<br>

### 원칙

#### 모듈을 명확히 구분해야 한다.

MSA에서 모듈을 명확하게 구분할 수 있는 것은 장점으로 작용한다.

하지만 명확한 경계가 존재하지 않으면 수정사항이 발생했을 때 특정 도메인의 마이크로 서비스 뿐만 아니라 다른것도 숙지하고 있어야 어디를 수정해야 할지 알 수 있다.

<br>

#### 마이크로 서비스는 독립적으로 배포할 수 있어야 한다.

각각의 마이크로 서비스들은 **독립적으로 배포**될 수 있어야 하며, 해당 비지니스 범위에 대한 모든 책임을 가져야 한다.

<br>

#### 하나의 서비스는 하나의 책임만 가져야 한다.

여기서 말하는 하나의 책임은, 유저 서비스가 게시글의 상태를 변경하는 등의 동작을 하면 안된다는 의미이다.

객체지향에서의 단일 책임 원칙과 비슷하다고 생각하면 된다.

<br>

### MSA가 해결해야 하는 과제

- **서비스 구축**

  서비스 간의 종속성을 고려해서 서비스를 어떻게 구분할지 시간을 투자해야 한다.

- **테스트**

  통합 테스트 등 여러 테스트를 수행하기 어렵다.

  Monolithic Application과 달리 다른 서비스들과 통신을 해야하기 때문에 고려할게 많다.

- **버전 관리**

  새로운 버전을 출시할 때 이전 버전과 호환성 문제가 발생할 수 있다.

- **배포**

  여러 마이크로 서비스들의 상당한 수준의 배포 자동화가 필요하다.

- **로깅**

  분산 시스템에서 발생한 로그들을 한 곳에 모을 수 있도록 해야한다.

- **모니터링**

  문제의 근원을 찾기 위해서는 중앙에서 모니터링 하는 기능이 필요하다.

- **디버그**

  수십 수백개의 마이크로 서비스는 디버깅할 수 없다.

  따라서 이 부분은 현재 해결방법이 없다.

<br>

## VS Monolithic Architecture

MSA와 가장 자주 비교되는 Monolithic Architecture 이다.

Monolithic Architecture는 **모든 서비스를 하나의 어플리케이션**에 담는 방법을 의미한다.

물론 DB 접근, 비지니스 로직의 처리 등을 논리적으론 나눌 수 있지만 결국 하나의 어플리케이션 내에서 동작하게 된다.

<br>

하지만 이러한 방식은 한계점이 존재한다.

계속해서 개발하고, 요구사항은 늘어가기 때문에 다음 문제들이 발생한다.

- **부분적인 Scale-Out이 불가능하다**

  트래픽이 몰렸을 때 어플리케이션 하나에 모두 담겨있기 때문에 부분적으로 Scale-Out을 할 수 없다.

- **배포에 시간이 오래 걸린다.**

- **하나의 기술에 종속적이다.**

  만약 프로젝트에서 Spring Boot를 사용하게 된다면, 모두가 Spring Boot로 기술스택을 맞춰야 한다.

<br>

물론 장점들도 존재한다.

- 로컬 개발이 간편하다.
- 테스트가 간편하다.
- 러닝커브가 낮다.